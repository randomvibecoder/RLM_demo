{
  "question": "What exact arithmetic trick is used in calc_delta_fair() to avoid division in the hot path?",
  "answer": "## Analysis of calc_delta_fair() Division Avoidance Trick\n\nLooking at the provided code in `kernel/sched/fair.c`, the arithmetic trick used to avoid division in the hot path is **multiplication by a reciprocal (inverse weight)** combined with **bit-shifting**.\n\n### The Core Trick\n\nThe comment in `__calc_delta()` explicitly explains this (around lines 87-96):\n\n```c\n/*\n * delta_exec * weight / lw.weight\n *   OR\n * (delta_exec * (weight * lw->inv_weight)) >> WMULT_SHIFT\n```\n\n### How It Works\n\n1. **Precomputed Inverse Weight** (lines 70-84):\n   ```c\n   static void __update_inv_weight(struct load_weight *lw)\n   {\n       unsigned long w;\n   \n       if (likely(lw->inv_weight))\n           return;\n   \n       w = scale_load_down(lw->weight);\n   \n       if (BITS_PER_LONG > 32 && unlikely(w >= WMULT_CONST))\n           lw->inv_weight = 1;\n       else if (unlikely(!w))\n           lw->inv_weight = WMULT_CONST;\n       else\n           lw->inv_weight = WMULT_CONST / w;   // <-- Precompute 2^32 / weight\n   }\n   ```\n   The `inv_weight` is precomputed as `WMULT_CONST / weight` where `WMULT_CONST = ~0U` (2^32).\n\n2. **Multiplication Instead of Division** (lines 106-120):\n   ```c\n   fact = mul_u32_u32(fact, lw->inv_weight);\n   // ... adjustment logic ...\n   return mul_u64_u32_shr(delta_exec, fact, shift);\n   ```\n   Instead of computing `delta_exec * weight / lw->weight`, it computes:\n   - `(delta_exec * weight * inv_weight) >> 32`\n   - Which simplifies to: `delta_exec * weight / lw->weight`\n\n### Why This Is Faster\n\n- **Division is slow**: On most architectures, integer division is significantly slower than multiplication and bit-shifts.\n- **Shift is fast**: The `WMULT_SHIFT` (32) is a simple right-shift operation.\n- **Precomputation**: The inverse weight is computed once (and cached) via `__update_inv_weight()`, avoiding repeated division in the hot path.\n\nThis is a classic **reciprocal multiplication** technique, similar to what compilers do when optimizing division by constants, but here it's applied dynamically to variable weights in the scheduler's most frequently executed code path.",
  "file": "kernel/sched/fair.c",
  "context_lines": "195-350"
}