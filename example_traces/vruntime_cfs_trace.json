{
  "question": "What is vruntime in CFS? How is it calculated?",
  "file": "kernel/sched/fair.c",
  "iterations": [
    {
      "iteration": 1,
      "type": "direct",
      "response": "\n**What is\u202f`vruntime` in CFS?**  \nIn the Completely Fair Scheduler (CFS) each schedulable entity (task or task\u2011group) keeps a **virtual runtime** (`vruntime`).  `vruntime` measures how much *fair* CPU time the entity has received, i.e. the amount of CPU time it would have run on an ideal, perfectly\u2011fair processor that can give every task an equal share of the CPU according to its weight (nice value).  CFS orders the run\u2011queue by putting the entity with the **smallest `vruntime`** at the left\u2011most node of the red\u2011black tree, so the next task to run is the one that has received the least fair CPU time.\n\n**How is it calculated?**  \n\nThe virtual runtime is updated every time the scheduler decides that the current entity has consumed some actual CPU time.  In `update_curr()` the update is done with:\n\n```c\ncurr->vruntime += calc_delta_fair(delta_exec, curr);\n```\n\n* `delta_exec` \u2013 the real (wall\u2011clock) amount of time the entity has just executed, obtained from `update_se()` (the function that"
    }
  ],
  "final_answer": "**What is\u202f`vruntime` in CFS?**  \nIn the Completely Fair Scheduler (CFS) each schedulable entity (task or task\u2011group) keeps a **virtual runtime** (`vruntime`).  `vruntime` measures how much *fair* CPU time the entity has received, i.e. the amount of CPU time it would have run on an ideal, perfectly\u2011fair processor that can give every task an equal share of the CPU according to its weight (nice value).  CFS orders the run\u2011queue by putting the entity with the **smallest `vruntime`** at the left\u2011most node of the red\u2011black tree, so the next task to run is the one that has received the least fair CPU time.\n\n**How is it calculated?**  \n\nThe virtual runtime is updated every time the scheduler decides that the current entity has consumed some actual CPU time.  In `update_curr()` the update is done with:\n\n```c\ncurr->vruntime += calc_delta_fair(delta_exec, curr);\n```\n\n* `delta_exec` \u2013 the real (wall\u2011clock) amount of time the entity has just executed, obtained from `update_se()` (the function that returns the elapsed time for the entity).  \n* `calc_delta_fair()` \u2013 an inline helper that *weights* the elapsed time by the entity\u2019s load weight relative to the weight of a nice\u20110 task (`NICE_0_LOAD`).  The typical implementation is:\n\n```c\nstatic inline u64 calc_delta_fair(u64 delta, struct sched_entity *se)\n{\n    if (se->load.weight == NICE_0_LOAD)\n        return delta;\n\n    return (u64)delta * se->load.weight / NICE_0_LOAD;\n}\n```\n\nBecause `se->load.weight` is larger for lower\u2011nice (higher\u2011priority) tasks, the term `se->load.weight / NICE_0_LOAD` is **\u2265\u202f1** for such tasks, meaning their `vruntime` grows **slower** per unit of real time.  Conversely, high\u2011nice (low\u2011weight) tasks have a smaller weight ratio, so their `vruntime` grows **faster**, causing them to be scheduled less often.\n\n**Citations**\n\n* The point where `vruntime` is updated:  \n  `kernel/sched/fair.c:1080` \u2013 `curr->vruntime += calc_delta_fair(delta_exec, curr);`\n\n* The helper that computes the fair delta:  \n  `kernel/sched/fair.c:366` \u2013 `calc_delta_fair()` definition (shows the weight\u2011scaling formula).\n\nTogether, these lines show that CFS tracks fairness by converting real execution time into a weighted virtual time (`vruntime`) and uses that value to order the run\u2011queue."
}