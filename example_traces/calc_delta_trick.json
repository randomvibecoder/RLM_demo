{
  "question": "What arithmetic trick in calc_delta_fair() avoids division? Explain WMULT_SHIFT.",
  "file": "kernel/sched/fair.c",
  "iterations": [
    {
      "iteration": 1,
      "type": "direct",
      "response": "**Answer**\n\nThe trick that avoids a real\u2011division in `calc_delta_fair()` is to replace the division by the run\u2011queue weight with a **fixed\u2011point multiplication** followed by a right\u2011shift.  \n\nThe idea is shown in the comment that precedes `__calc_delta`:\n\n```\n/*\n * delta_exec * weight / lw.weight\n *   OR\n * (delta_exec * (weight * lw->inv_weight)) >> WMULT_SHIFT\n */\n```\n\n*(kernel/sched/fair.c\u202flines\u202f2\u20117)*  \n\nInstead of computing `delta / lw->weight` directly, the code pre\u2011computes an inverse weight (`lw->inv_weight`) and evaluates  \n\n```\n(delta * weight * lw->inv_weight) >> WMULT_SHIFT\n```\n\nwhich is mathematically equivalent but uses only multiplication and a shift.  \n\nIn `calc_delta_fair()` the call to `__calc_delta()` performs exactly this operation:\n\n```c\nif (unlikely(se->load.weight != "
    }
  ],
  "final_answer": "**Answer**\n\nThe trick that avoids a real\u2011division in `calc_delta_fair()` is to replace the division by the run\u2011queue weight with a **fixed\u2011point multiplication** followed by a right\u2011shift.  \n\nThe idea is shown in the comment that precedes `__calc_delta`:\n\n```\n/*\n * delta_exec * weight / lw.weight\n *   OR\n * (delta_exec * (weight * lw->inv_weight)) >> WMULT_SHIFT\n */\n```\n\n*(kernel/sched/fair.c\u202flines\u202f2\u20117)*  \n\nInstead of computing `delta / lw->weight` directly, the code pre\u2011computes an inverse weight (`lw->inv_weight`) and evaluates  \n\n```\n(delta * weight * lw->inv_weight) >> WMULT_SHIFT\n```\n\nwhich is mathematically equivalent but uses only multiplication and a shift.  \n\nIn `calc_delta_fair()` the call to `__calc_delta()` performs exactly this operation:\n\n```c\nif (unlikely(se->load.weight != NICE_0_LOAD))\n    delta = __calc_delta(delta, NICE_0_LOAD, &se->load);\n```\n\n*(kernel/sched/fair.c\u202fline\u202f38\u201140)*  \n\nThe implementation inside `__calc_delta()` (lines\u202f14\u201130) multiplies `delta` by `fact` (which is `weight * lw->inv_weight`) and then calls `mul_u64_u32_shr()` to shift the product right by `shift`. The initial value of `shift` is set to `WMULT_SHIFT`:\n\n```c\nint shift = WMULT_SHIFT;\n```\n\n*(kernel/sched/fair.c\u202fline\u202f18)*  \n\n---\n\n### What is `WMULT_SHIFT`?\n\n`WMULT_SHIFT` is a constant that defines the number of bits used for the fractional part in the fixed\u2011point arithmetic. It is the shift count applied to the product to emulate the division by the original weight.  \n\nThe comment explains why the shift is always positive:\n\n* \u201cinv_weight is guaranteed to fit 32 bits, and NICE_0_LOAD gives another 10 bits; therefore shift\u202f\u2265\u202f22.\u201d (lines\u202f10\u201112)  \n* Or, if `weight \u2264 lw->weight`, the ratio `weight/lw->weight \u2264 1`, so the shift also stays positive.\n\nThus, `WMULT_SHIFT` is the **scale factor** that converts the multiplication result back to the correct magnitude, effectively performing the division without using a division instruction."
}