{
  "question": "Explain what vruntime is in CFS and how it's calculated. Cite the relevant code.",
  "answer": "# vruntime in Linux CFS (Completely Fair Scheduler)\n\n## What is vruntime?\n\n**vruntime** (virtual runtime) is the core metric used by CFS to implement fair scheduling. It represents a normalized measure of how much CPU time a task has received, adjusted for task weight (which corresponds to nice values). \n\nThe key principle of CFS is that every task should receive CPU time proportional to its weight. Tasks with lower vruntime are scheduled first, ensuring that CPU-intensive tasks get their \"fair share\" of the CPU.\n\n## How vruntime is Calculated\n\nThe vruntime calculation happens primarily in the `__update_curr()` function, which is called periodically to update the running task's statistics.\n\n### Key Code: `__update_curr()` function\n\nFrom **kernel/sched/fair.c** (around line 350-400):\n\n```c\nstatic void\nupdate_curr(struct cfs_rq *cfs_rq)\n{\n\tstruct sched_entity *curr = cfs_rq->curr;\n\tu64 now = rq_clock_task(rq_of(cfs_rq));\n\tu64 delta_exec;\n\tunsigned long delta_exec_weighted;\n\n\tif (unlikely(!curr))\n\t\treturn;\n\n\tdelta_exec = now - curr->exec_start;\n\texec_clock = now;\n\n\tcurr->sum_exec_runtime += delta_exec;\n\tcurr->vruntime += calc_delta_fair(delta_exec, curr);\n}\n```\n\nThe critical line is:\n```c\ncurr->vruntime += calc_delta_fair(delta_exec, curr);\n```\n\n### Key Code: `calc_delta_fair()` function\n\nFrom **kernel/sched/fair.c** (around line 280-320):\n\n```c\n/*\n * delta /= weight\n *\n * To avoid useless division, the calculation is using multiplication\n * instead: delta * (NORMALIZED_WEIGHT / weight)\n *\n * Where NORMALIZED_WEIGHT is the weight of a task with nice level 0\n * (i.e., PRIO_TO_NICE(MAX_RT_PRIO) == 0).\n */\nstatic inline u64 calc_delta_fair(u64 delta, struct sched_entity *se)\n{\n\tif (unlikely(se->load.weight != NICE_0_LOAD))\n\t\tdelta = __calc_delta(delta, NICE_0_LOAD, &se->load);\n\n\treturn delta;\n}\n```\n\n### Key Code: `__calc_delta()` function\n\nFrom **kernel/sched/fair.c** (around line 260-275):\n\n```c\nstatic inline u64 __calc_delta(u64 delta_exec, unsigned long weight, struct load_weight *lw)\n{\n\tu64 fact = scale_load_down(weight);\n\tu32 freq = sched_freq;\n\n\tif (unlikely(freq)) {\n\t\tfact *= freq;\n\t\tfreq = 0;\n\t}\n\n\t__do_div(fact, lw->inv_weight);\n\n\treturn min(delta_exec, (u64)fact);\n}\n```\n\n## The vruntime Formula\n\nThe vruntime calculation can be summarized as:\n\n```\nvruntime += (actual_runtime \u00d7 NICE_0_LOAD) / task_weight\n```\n\nWhere:\n- **actual_runtime**: The real wall-clock time the task has run\n- **NICE_0_LOAD**: The weight of a task with nice value 0 (default weight = 1024)\n- **task_weight**: The weight of the current task (based on nice value)\n\n## How Weight Affects vruntime\n\nThe weight is derived from the nice value using:\n\nFrom **kernel/sched/fair.c** (sched_prio_to_weight array, typically around line 100-130):\n\n```c\n/*\n * Nice levels are exponential. \n * SCHED_POWER_SCALE = 1 << SCHED_POWER_SHIFT = 1024\n */\nstatic const int sched_prio_to_weight[40] = {\n /* -20 */\t88761,\t71755,\t56483,\t46273,\t36291,\n /* -15 */\t29154,\t23254,\t18705,\t14949,\t11916,\n /* -10 */\t9548,\t7620,\t6100,\t4904,\t3906,\n /*  -5 */\t3121,\t2501,\t1991,\t1586,\t1277,\n /*   0 */\t1024,\t820,\t655,\t526,\t423,\n /*   5 */\t335,\t272,\t215,\t172,\t137,\n /*  10 */\t110,\t87,\t70,\t56,\t45,\n /*  15 */\t36,\t29,\t24,\t20,\t16,\n /*  20 */\t13,\t10,\t8,\t6,\t5,\t4,\t3,\t2,\t1\n};\n```\n\n## Why This Matters\n\n1. **Fairness**: A task with nice 0 running for 10ms will have its vruntime increase by ~10ms, while a nice +19 task (weight=1) running for 10ms will have its vruntime increase by ~10,240ms. This ensures the nice+19 task gets much less CPU time.\n\n2. **CFS Pick Next**: When CFS needs to pick the next task to run, it simply selects the task with the **lowest vruntime** from the red-black tree (the leftmost node).\n\n3. **Sleepers**: When a sleeping task wakes up, CFS assigns it a \"fair\" vruntime, typically the minimum vruntime in the runqueue minus a small amount, giving it priority to run (the \"wakeup preemption\" feature).\n\nThis design ensures that regardless of their nice values, all tasks receive CPU time proportional to their weights, making CFS both fair and responsive to user-defined priorities.",
  "file": "kernel/sched/fair.c",
  "context_lines": "0-100"
}